
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../Lab2/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.2">
    
    
      
        <title>Lab1 - Web-labs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Web-labs" class="md-header__button md-logo" aria-label="Web-labs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Web-labs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Lab1
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Web-labs" class="md-nav__button md-logo" aria-label="Web-labs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Web-labs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Intro
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Lab1
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Lab1
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      Работа с сокетами
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 1
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 3
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 4
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 5
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Lab2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab2
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Lab3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab3
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Lab4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab4
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Practice3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Practice3
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      Работа с сокетами
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 1
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 3
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 4
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      Задание 5
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>Lab1</h1>

<h3 id="_1">Работа с сокетами</h3>
<h3 id="1">Задание 1</h3>
<p>Реализовать клиентскую и серверную часть приложения. Клиент отсылает серверу
сообщение «Hello, server». Сообщение должно отразиться на стороне сервера.
Сервер в ответ отсылает клиенту сообщение «Hello, client». Сообщение должно
отобразиться у клиента. Обязательно использовать библиотеку socket. Реализовать с помощью протокола UDP.</p>
<p><strong>Код:</strong></p>
<pre><code># server.py
import socket

# Создаем UDP-сервер
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 12345)
server_socket.bind(server_address)

while True:
    print("Ожидание сообщения от клиента...")
    data, client_address = server_socket.recvfrom(1024)
    print(f"Получено сообщение от клиента: {data.decode()}")

    response = "Hello, client"
    server_socket.sendto(response.encode(), client_address)
</code></pre>
<ul>
<li>Создается UDP-сервер с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>UDP-сокет привязывается к указанному адресу с помощью server_socket.bind(server_address).</li>
<li>Затем сервер начинает бесконечный цикл (while True) и ожидает прихода сообщений от клиентов.</li>
<li>Когда сервер получает сообщение от клиента, оно считывается с помощью server_socket.recvfrom(1024). Здесь 1024 - максимальный размер данных, которые можно получить за один раз.</li>
<li>После получения сообщения, сервер отправляет ответное сообщение ("Hello, client") обратно клиенту с помощью server_socket.sendto(response.encode(), client_address).</li>
</ul>
<pre><code class="language-python"># client.py
import socket

# Создаем UDP-клиента
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 12345)

message = &quot;Hello, server&quot;
client_socket.sendto(message.encode(), server_address)

data, server_address = client_socket.recvfrom(1024)
print(f&quot;Получено сообщение от сервера: {data.decode()}&quot;)

client_socket.close()
</code></pre>
<ul>
<li>Создается UDP-клиент с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>Клиент создает сообщение (message), в данном случае "Hello, server", и отправляет его серверу с помощью client_socket.sendto(message.encode(), server_address).</li>
<li>Затем клиент ожидает ответное сообщение от сервера, которое получается с помощью client_socket.recvfrom(1024).</li>
<li>Полученное сообщение ("Hello, client") декодируется и выводится на экран.</li>
<li>Наконец, клиент закрывает сокет с помощью client_socket.close().</li>
</ul>
<p><img alt="Текст с описанием картинки" src="../img/Lab1.1.png" /></p>
<h3 id="2">Задание 2</h3>
<p>Реализовать клиентскую и серверную часть приложения. Клиент запрашивает у
сервера выполнение математической операции, параметры, которые вводятся с
клавиатуры. Сервер обрабатывает полученные данные и возвращает результат
клиенту. Варианты:</p>
<p><strong>a. Теорема Пифагора</strong>
b. Решение квадратного уравнения.
c. Поиск площади трапеции.
d. Поиск площади параллелограмма.</p>
<p>Вариант выбирается в соответствии с порядковым номером в журнале. Пятый
студент получает вариант 1 и т.д. Обязательно использовать библиотеку socket. Реализовать с помощью протокола TCP</p>
<p><strong>Код:</strong></p>
<pre><code># server.py
import socket

# Создаем TCP-сервер
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 12345)
server_socket.bind(server_address)

server_socket.listen(1)
print("Сервер запущен. Ожидание подключения клиента...")

while True:
    client_connection, client_address = server_socket.accept()
    print(f"Подключение от клиента {client_address}")

    # Принимаем данные от клиента
    data = client_connection.recv(1024).decode()
    print(f"Получено сообщение от клиента: {data}")

    # Разбираем данные и выполняем математическую операцию (теорема Пифагора)
    try:
        a, b = map(float, data.split(','))
        c = (a ** 2 + b ** 2) ** 0.5
        response = f"Гипотенуза (c) равна {c}"
    except ValueError:
        response = "Ошибка: Некорректные данные"

    # Отправляем результат клиенту
    client_connection.send(response.encode())
    client_connection.close()
</code></pre>
<ul>
<li>Создается TCP-сервер с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>TCP-сокет привязывается к указанному адресу с помощью server_socket.bind(server_address).</li>
<li>server_socket.listen(1) устанавливает сервер в режим ожидания подключения клиента с максимальным количеством ожидаемых клиентских соединений, равным 1.</li>
<li>Затем сервер начинает бесконечный цикл (while True) и ожидает подключения клиента с помощью server_socket.accept(). Как только клиент подключается, создается новое соединение (client_connection) и получается адрес клиента (client_address).</li>
<li>Далее сервер принимает данные от клиента с помощью client_connection.recv(1024).decode(), где 1024 - максимальный размер данных, которые можно получить за один раз.</li>
<li>Полученные данные разбираются на два числа (предполагается, что клиент отправляет два числа, разделенных запятой), и на основе этих данных вычисляется гипотенуза по теореме Пифагора.</li>
<li>Результат вычисления отправляется обратно клиенту с помощью client_connection.send(response.encode()).</li>
<li>Соединение с клиентом закрывается с помощью client_connection.close().</li>
</ul>
<pre><code class="language-python"># client.py
import socket

# Создаем TCP-клиента
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 12345)

try:
    # Вводим данные с клавиатуры
     a = float(input(&quot;Введите длину первого катета: &quot;))
     b = float(input(&quot;Введите длину второго катета: &quot;))

     # Отправляем данные серверу
     message = f&quot;{a},{b}&quot;
     client_socket.connect(server_address)
     client_socket.send(message.encode())

     # Получаем и выводим ответ от сервера
     data = client_socket.recv(1024).decode()
     print(f&quot;Ответ от сервера: {data}&quot;)
except ValueError:
    print(&quot;Ошибка: Введите числовые значения для длин катетов.&quot;)
finally:
    client_socket.close()
</code></pre>
<ul>
<li>Создается TCP-клиент с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>Пользователю предлагается ввести длину двух катетов с клавиатуры.</li>
<li>Введенные данные отправляются серверу в виде строки, где две длины катетов разделены запятой.</li>
<li>Затем клиент ожидает ответа от сервера с помощью client_socket.recv(1024).decode() и выводит результат на экран.</li>
</ul>
<h3 id="3">Задание 3</h3>
<p>Реализовать серверную часть приложения. Клиент подключается к серверу. В ответ
клиент получает http-сообщение, содержащее html-страницу, которую сервер
подгружает из файла index.html. Обязательно использовать библиотеку socket.</p>
<p><strong>Код:</strong></p>
<pre><code># server.py
import socket

# Загружаем содержимое HTML-файла
with open("index.html", "r") as file:
    html_content = file.read()

# Создаем HTTP-сервер
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 8080)
server_socket.bind(server_address)

server_socket.listen(1)
print("Сервер запущен. Ожидание подключения клиента...")

while True:
    client_connection, client_address = server_socket.accept()
    print(f"Подключение от клиента {client_address}")

    http_response = f"HTTP/1.1 200 OK\r\nContent-Length: {len(html_content)}\r\n\r\n{html_content}"
    client_connection.sendall(http_response.encode())
    client_connection.close()
</code></pre>
<ul>
<li>Сначала он загружает содержимое HTML-файла index.html в переменную html_content. Это делается с помощью открытия файла и чтения его содержимого.</li>
<li>Затем создается TCP-сервер с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 8080.</li>
<li>TCP-сокет привязывается к указанному адресу с помощью server_socket.bind(server_address).</li>
<li>server_socket.listen(1) устанавливает сервер в режим ожидания подключения клиента с максимальным количеством ожидаемых клиентских соединений, равным 1.</li>
<li>Затем сервер начинает бесконечный цикл (while True) и ожидает подключения клиента с помощью server_socket.accept(). Как только клиент подключается, создается
новое соединение (client_connection) и получается адрес клиента (client_address).</li>
<li>Сервер формирует HTTP-ответ, включая статус "200 OK" и длину содержимого HTML-файла, и отправляет его клиенту с помощью client_connection.sendall(http_response.encode()).</li>
<li>Соединение с клиентом закрывается с помощью client_connection.close().</li>
</ul>
<pre><code class="language-html"># index.html
&lt;!DOCTYPE html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;My Love for Charles Leclerc&lt;/title&gt;
        &lt;style&gt;
            body {
                font-family: Montserrat, sans-serif;
                background-color: #f2f2f2;
                text-align: center;
                padding: 100px;
            }
            h1 {
                color: red;
            }
            p {
                color: red;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;I love Charles Leclerc&lt;/h1&gt;
        &lt;p&gt;Scuderia Ferrari&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><img alt="Текст с описанием картинки" src="../img/Lab1.3.png" /></p>
<h3 id="4">Задание 4</h3>
<p>Реализовать двухпользовательский или многопользовательский чат. Реализация многопользовательского часа позволяет получить максимальное количество баллов. Обязательно использовать библиотеку socket. Реализовать с помощью протокола TCP – 100% баллов, с помощью UDP – 80%. Обязательно использовать библиотеку threading. Для реализации с помощью UDP, thearding использовать для получения сообщений у клиента. Для применения с TCP необходимо запускать клиентские подключения <strong>и</strong> прием и отправку сообщений всем юзерам на сервере в потоках. Не забудьте сохранять юзеров, чтобы потом отправлять им сообщения.</p>
<p><strong>Код:</strong></p>
<pre><code># server.py
import socket
import threading

# Создаем TCP-сервер
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 12345)
server_socket.bind(server_address)

# Список клиентов и их соединений
clients = []
client_lock = threading.Lock()

def broadcast_message(message, sender):
    with client_lock:
        for client in clients:
            if client != sender:
                try:
                    client.send(message.encode())
                except:
                    # Если отправка сообщения не удалась, удаляем клиента из списка
                    remove_client(client)

def remove_client(client):
    with client_lock:
        if client in clients:
            clients.remove(client)

def client_handler(client_socket):
    while True:
        try:
            message = client_socket.recv(1024).decode()
            if not message:
                break
            broadcast_message(message, client_socket)
        except:
            pass  # Обработка ошибок

    # Удаляем клиента из списка и закрываем соединение
    remove_client(client_socket)
    client_socket.close()

server_socket.listen(5)
print("Сервер чата запущен. Ожидание подключения клиентов...")

while True:
    client_connection, client_address = server_socket.accept()
    print(f"Подключение от {client_address}")

    with client_lock:
        clients.append(client_connection)

    # Создаем отдельный поток для обработки клиента
    client_thread = threading.Thread(target=client_handler, args=(client_connection,))
    client_thread.start()
</code></pre>
<ul>
<li>Создается TCP-сервер с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>TCP-сокет привязывается к указанному адресу с помощью server_socket.bind(server_address).</li>
<li>Создается список clients для отслеживания всех клиентских соединений.</li>
<li>Создается объект блокировки (client_lock) для безопасного доступа к списку клиентов из нескольких потоков.</li>
<li>Определяется функция broadcast_message(message, sender), которая отправляет сообщение всем клиентам, кроме отправителя.</li>
<li>Определяется функция remove_client(client), которая удаляет клиента из списка клиентов.</li>
<li>Определяется функция client_handler(client_socket), которая обрабатывает входящие сообщения от клиента и передает их другим клиентам.</li>
<li>Сервер начинает слушать подключения с максимальной длиной очереди ожидания равной 5 с помощью server_socket.listen(5).</li>
<li>Затем сервер начинает бесконечный цикл (while True) и ожидает подключения клиентов с помощью server_socket.accept(). Как только клиент подключается, его сокет добавляется в список clients.</li>
<li>Для каждого подключенного клиента создается отдельный поток (client_thread) для обработки сообщений от него.</li>
</ul>
<pre><code class="language-python"># client.py
import socket
import threading

# Создаем TCP-клиента
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 12345)

# Вводим имя пользователя
client_name = input(&quot;Введите ваше имя: &quot;)

client_socket.connect(server_address)

def receive_messages():
    while True:
        try:
            message = client_socket.recv(1024).decode()
                print(message)
        except Exception as e:
            print(f&quot;Ошибка: {e}&quot;)
        break

receive_thread = threading.Thread(target=receive_messages)
receive_thread.start()

while True:
    message = input()
        if message.lower() == &quot;exit&quot;:
            break

        client_socket.send(f&quot;{client_name}: {message}&quot;.encode())

    client_socket.close()
</code></pre>
<ul>
<li>Создается TCP-клиент с использованием библиотеки socket.</li>
<li>Устанавливается адрес сервера (server_address), который указывает на локальный хост (localhost) и порт 12345.</li>
<li>Пользователю предлагается ввести имя пользователя.</li>
<li>Клиент подключается к серверу с помощью client_socket.connect(server_address).</li>
<li>Запускается отдельный поток (receive_thread), который слушает входящие сообщения от сервера и выводит их на экран.</li>
<li>Основной поток клиента ожидает ввода сообщений пользователя. Когда пользователь отправляет сообщение, оно отправляется на сервер.</li>
</ul>
<p><img alt="Текст с описанием картинки" src="../img/Lab1.4.png" />
<img alt="Текст с описанием картинки" src="../img/Lab1.4.1.png" /></p>
<h3 id="5">Задание 5</h3>
<p>Необходимо написать простой web-сервер для обработки GET и POST http
запросов средствами Python и библиотеки socket.
Задание: сделать сервер, который может:
- Принять и записать информацию о дисциплине и оценке по дисциплине.
- Отдать информацию обо всех оценах по дсициплине в виде html-страницы.</p>
<p><strong>Код:</strong></p>
<pre><code># server.py
import socket
from email.parser import Parser
from functools import lru_cache
from urllib.parse import parse_qs, urlparse
MAX_LINE = 64 * 1024
MAX_HEADERS = 100

class MyHTTPServer:

    def __init__(self, method, target, version, headers, rfile):
        self.method = method
        self.target = target
        self.version = version
        self.headers = headers
        self.rfile = rfile

    @property
    def path(self):
        return self.parsed_url.path

    @property
    def body(self):
        size = self.headers.get('Content-Length')
        if not size:
            return None
        content = self.rfile.read(int(size))
        return content.decode('utf-8')

    @property
    @lru_cache(maxsize=None)
    def parsed_url(self):
        return urlparse(self.target)

    @property
    @lru_cache(maxsize=None)
    def query_parameters(self):
        return parse_qs(self.parsed_url.query)

    @property
    @lru_cache(maxsize=None)
    def form_parameters(self):
        return parse_qs(self.body)


class CustomResponse:
    def __init__(self, status, reason, headers=None, body=None):
        self.status = status
        self.reason = reason
        self.headers = headers
        self.body = body


class HTTPServer:
    def __init__(self, server_address):
        self.server_address = server_address
        self.connection = None
        self.grades_data = {}  # {subject: [grades]}

    def start(self):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            server_socket.bind(self.server_address)
            server_socket.listen(10)
            print("Server is running...")
            while True:
                client_socket, _ = server_socket.accept()
                try:
                    self.handle_client(client_socket)
                except Exception as e:
                    print('Connection failed', e)
        finally:
            server_socket.close()
            print("Server stopped")

    def handle_client(self, conn):
        try:
            request = self.parse_request(conn)
            response = self.handle_request(request)
            self.send_response(conn, response)
        except ConnectionResetError:
            conn = None
        except Exception as e:
            print("Error", e)
        if conn:
            conn.close()

    def parse_request(self, conn):
        rfile = conn.makefile('rb')
        raw_request = rfile.readline(MAX_LINE + 1)
        if len(raw_request) &gt; MAX_LINE:
            raise Exception('Request line is too long')

        request_line = str(raw_request, 'iso-8859-1')
        request_line = request_line.rstrip('\r\n')
        method, target, version = request_line.split()
        if version != 'HTTP/1.1':
            raise Exception('Unexpected HTTP version')

        headers = self.parse_headers(rfile)
        host = headers.get('Host')
        if not host:
            raise Exception('Bad request')

        return MyHTTPServer(method, target, version, headers, rfile)

    @staticmethod
    def parse_headers(rfile):
        headers = []
        while True:
            line = rfile.readline(MAX_LINE + 1)
            if len(line) &gt; MAX_LINE:
                raise Exception('Header line is too long')

            if line in (b'\r\n', b'\n', b''):
                break

            headers.append(line)
            if len(headers) &gt; MAX_HEADERS:
                raise Exception('Too many headers')

        parsed_headers = b''.join(headers).decode('iso-8859-1')
        return Parser().parsestr(parsed_headers)

    def handle_request(self, request):
        if request.path == '/' and request.method == 'POST':
            return self.handle_post(request)
        if request.method == 'GET':
            if request.path == '/add_grade':
                body = """&lt;!DOCTYPE html&gt;
                        &lt;html lang="ru"&gt;
                        &lt;style&gt;
                            body {
                                font-family: Montserrat, sans-serif;
                                background-color: #e3ecfa;
                                text-align: center;
                                padding: 200px;
                            }
                            h2 {
                                color: #8ab2f2;
                            }
                            p {
                                color: #666;
                                font-size: 20px;
                            }
                        &lt;/style&gt;
                        &lt;head&gt;
                            &lt;meta charset="UTF-8"&gt;
                            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                        &lt;/head&gt;
                        &lt;script&gt;
                            // JavaScript скрипты здесь
                        &lt;/script&gt;
                        &lt;body&gt;
                            &lt;h2&gt;ENTER THE GRADE&lt;/h2&gt;
                            &lt;form method="POST" action="/"&gt;
                                &lt;input type="text" id="subject" name="subject" placeholder="Subject"&gt;
                                &lt;input type="text" id="grade" name="grade" placeholder="Grade"&gt;
                                &lt;input type="submit" value="Send" style="background-color: #8ab2f2; color: #fff; padding: 10px 20px; border: none; cursor: pointer;border-radius: 20px;"&gt;
                            &lt;/form&gt;
                            &lt;form action="/"&gt;
                                &lt;input type="submit" value="To the main page"/ style="background-color: #8ab2f2; color: #fff; padding: 10px 20px; border: none; cursor: pointer;border-radius: 20px;"&gt;
                            &lt;/form&gt;
                        &lt;/body&gt;
                        """
                return self.handle_get(body)
            elif request.path == '/':
                return self.handle_get()
        content = """&lt;!DOCTYPE html&gt;
                &lt;html lang="ru"&gt;
                &lt;style&gt;
                    body {
                        font-family: Montserrat, sans-serif;
                        background-color: #e3ecfa;
                        text-align: center;
                        padding: 200px;
                    }
                    h2 {
                        color: #8ab2f2;
                    }
                    p {
                        color: #666;
                        font-size: 20px;
                    }
                &lt;/style&gt;
                &lt;body&gt;
                    &lt;h2&gt;Error 404&lt;/h2&gt;
                    &lt;form action="/"&gt;
                        &lt;input type="submit" value="To the main page"/ style="background-color: #8ab2f2; color: #fff; padding: 10px 20px; border: none; cursor: pointer;border-radius: 20px;"&gt;
                    &lt;/form&gt;
                &lt;/body&gt;
                &lt;/html&gt;
                """
        return self.handle_get(content)

    def handle_get(self, body=None):
        content_type = 'text/html; charset=utf-8'
        if body is None:
            body = """
                &lt;!DOCTYPE html&gt;
                &lt;html lang="ru"&gt;
                &lt;style&gt;
                    body {
                        font-family: Montserrat, sans-serif;
                        background-color: #e3ecfa;
                        text-align: center;
                        padding: 200px;
                    }
                    h2 {
                        color: #8ab2f2;
                    }
                    p {
                        color: #8ab2f2;
                        font-size: 20px;
                    }
                &lt;/style&gt;
                &lt;head&gt;
                    &lt;meta charset="UTF-8"&gt;
                    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;h2&gt;YOUR GRADES&lt;/h2&gt;
                    &lt;table&gt;
                        &lt;tr&gt;
                            &lt;th&gt;Subject&lt;/th&gt;
                            &lt;th&gt;Grade&lt;/th&gt;
                        &lt;/tr&gt;
                """
            for subject, grades in self.grades_data.items():
                for grade in grades:
                    body += f"""
                            &lt;tr&gt;
                                &lt;td&gt;{subject}&lt;/td&gt;
                                &lt;td&gt;{grade}&lt;/td&gt;
                            &lt;/tr&gt;
                        """

            body += """
                    &lt;/table&gt;
                    &lt;form action="/add_grade"&gt;
                        &lt;input type="submit" value="Add grade" style="background-color: #8ab2f2; color: #fff; padding: 10px 20px; border: none; cursor: pointer;border-radius: 20px;"&gt;
                    &lt;/form&gt;
                &lt;/body&gt;
                &lt;/html&gt;
                """

        body = body.encode('utf-8')
        headers = [('Content-Type', content_type),
                ('Content-Length', len(body))]
        return CustomResponse(200, 'OK', headers, body)

    def handle_post(self, request):
        subject = request.form_parameters['subject'][0]
        grade = request.form_parameters['grade'][0]
        try:
            self.grades_data.setdefault(subject, []).append(grade)
        except KeyError:
            self.grades_data[subject] = [grade]
        return self.handle_get()

    @staticmethod
    def send_response(conn, response):
        wfile = conn.makefile('wb')
        status_line = f'HTTP/1.1 {response.status} {response.reason}\r\n'
        wfile.write(status_line.encode('iso-8859-1'))

        if response.headers:
            for (key, value) in response.headers:
                header_line = f'{key}: {value}\r\n'
                wfile.write(header_line.encode('iso-8859-1'))

        wfile.write(b'\r\n')

        if response.body:
            wfile.write(response.body)

        wfile.flush()
        wfile.close()


if __name__ == '__main__':
    server_address = ('127.0.0.1', 8080)
    http_server = HTTPServer(server_address)
    http_server.start()
</code></pre>
<p><img alt="Текст с описанием картинки" src="../img/Lab1.5.png" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d7c377c4.min.js"></script>
      
    
  </body>
</html>